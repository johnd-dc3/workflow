# Tips and Tools
- `bin/rails console` will open irb

# Terminology
## Basic Terminology
  - A **hash** is an associative array of unique keys and their values
    - Alternative syntax can be used when defining the key names of a hash, using `:` at the end of the hash name, thus converting the key name into a symbol.
    ```
    { foo: 1, bar: 2 }
    #=> {:foo=>1, :bar=>2}
    ```
  - A **symbol** is a literal, static name that doesn't change, and is designated by a `:` in front of the name. Example: `:articles`. Controller names, for example, are defined as symbles. Symbols are memory efficient
  - An **instance variable** (ex.: `@variableName`) is restricted to the object that itself refers to
  - A **method** is just a function. Many methods are built-in, but can also be created. You can pass parameters to a method with or without parentheses:
  ```
  add_two 2
  add_two(2)
  ```
  - **Parameters** are arguments passed to a method. In a web app there are two types: 1) query string parameters, which received from the browser URL in a GET request, and 2) POST data which comes from form info entered by the user. Rails treats the two types the same, using the `params` hash
  - **params** is a built in hash that allows access to an object's properties. For example, a controller's show actions may be defines using params:
  ```
    def show
    @article = Article.find(params[:id])
  end
  ```
  Here, when a GET request is made (show action), an instance varialbe `@article` is created. The article is defined by running a `find` method on the Article model (a table full of articles). Find is passed a params hash with the value of the ID defined from the URL

## Model
- A model is a Ruby class that can add, find, update, and remove data from a database (CRUD). Rails automatically generates models.
- Use the generate command to build a model:
  ```
  bin/rails generate model ModelName ColumnOneName:ColumnOneType ColumnTwoName:ColumnTwoType
  ```
  Ex.: `bin/rails generate model Article title:string body:text`
- The above model generation **creates the constructor class CreateArticles for the article object** This object will later be accessed by used of an instance varialbe in the controller
- Generating the model will also generate a migration file. Migrations define changes that will be made to the database. Migration files defined in Ruby are database-agnositc

### [Adding columns to a table](https://stackoverflow.com/questions/4834809/adding-a-column-to-an-existing-table-in-a-rails-migration)


## Migration File
Here is an example of a migration file automatically generated when a model was generated:
```
class CreateArticles < ActiveRecord::Migration[6.1]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :body

      t.timestamps
    end
  end
end
```
- `CreateArticles` was automatically generated when the `Article` model was generated. `CreateArticles` inherits the functionality of ActiveRecord's Migration class. The Migrations class in ActiveRecord contains helper methods that perform CRUD operations, like addtable, addcolumn, and rename_table. These are the types of things we want our class to do, so it inherits those methods, giving our class the ability to perform them.
- The `change` method is defined by default as a constructive migration method. It will generate a table with the specified columns as well as timestamps for creation and updates

## Controller
The controller uses the model to access the database in some way
- Controllers can be generated in the bash terminal using the following:
  `bin/rails generate controller ControllerName actionName --skip-routes`. Note that `--skip-routes` is optional
- Once the controller is generated, the controller file will be generated. Ex: `app/controllers/articles_controller.rb`
- Additionally, a view will be generated by default. Ex: `app/views/articles/index.html.erb`

### Accessing data via instance variables in the Controller
The Controller makes use of **instance variables** (ex.: `@articles`). When an action is triggered (E.g.: user clicks on New button), an instance of the controller is created and the `new` method is called. At that point, any instance variables defined are available to any method or view that is the result of that action. **This is especially important for connecting variable data between the controller and the view**

Instance variables will typically be defined as a model (table) with a method called on it. Ex.: `@articles = Article.all`

### Using strong parameters
when using the create action, you are allowing the user access to every parameter in your table, which is dangerous. Instead you must use a private method, and define only those parameters you are allowing access to:
```
  private
  def article_params
    params.require(:article).permit(:title, :body)
  end
end
```

## Routes
Connect incoming HTTP requests to application and generates URLS (no hard coded URLS)
- **routes.rb** is a single block sent to `ActionController::Routing::Routes.draw`
- Routes assign a controller and an action to a URL. I.e.: routes will map a URL _to_ an action _of_ a controller
- URLs are mapped by the controller's action (GET, POST, DELETE, PATCH, PUT)
- `resources` routings iwll difine all common routes for a controller
- RESTful routes use the following declaration style: `resources :controller-name`
- Models that are dependent upon other models must be nested
- A **resource** includes all of the following built in RESTful routes:
```
bin/rails routes
      Prefix Verb   URI Pattern                  Controller#Action
        root GET    /                            articles#index
    articles GET    /articles(.:format)          articles#index
 new_article GET    /articles/new(.:format)      articles#new
     article GET    /articles/:id(.:format)      articles#show
             POST   /articles(.:format)          articles#create
edit_article GET    /articles/:id/edit(.:format) articles#edit
             PATCH  /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
```

# Initial Setup
Assuming you have Ruby and Rails already installed:
1. Create your app: `rails new blog --skip-spring --skip-listen` (Note: this is specifically for Linux running on a Windows subsystem)
3. Start app: `bin/rails server` to confirm it is connected
4. Add your first route, for example:
  ```
  Rails.application.routes.draw do
  root "articles#index"
  end
  ```
5. Generate your controller from bash terminal: `bin/rails generate controller Articles index --skip-routes`
6. Generate your model: `bin/rails generate model Article title:string body:text
7. Run your migration: `bin/rails db:migrate`

# The Form Builder
- Forms will be found under `app/views/articles/new.html.erb `
- The form will be wrapped in the following:
```
<%= form_with model: @article do |form| %>
...
<% end %>
```
- `form_with` is a helper method that instantiates the form
- `:model` is passed to `form_with` as a resource, with all its RESTful routes
- @article instance variable will pass the @article URL and POST route on submit
- If using a form as a partial replace the instance variable (`@article`) with a local variable (`article`).  Because partials are shared code, it is best practice that they do not depend on specific instance variables set by a controller action. 

# Partials
- Partials should be saved under the appropriate veiws folder, and the title should begin with an underscore. Ex.: `app/views/articles/_form.html.erb`
- Use `render` to access the partial: `<%= render "form", article: @article %>`








